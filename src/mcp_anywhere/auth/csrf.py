"""CSRF protection for OAuth flows using state parameter validation.

This module provides CSRF protection specifically for OAuth authorization flows
by implementing secure state parameter generation and validation. The state
parameters are stored in memory with expiration to prevent replay attacks.
"""

import logging
import secrets
import time
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class CSRFState:
    """CSRF state parameter data for OAuth flow protection.

    Attributes:
        value: The actual state parameter value (URL-safe random string)
        client_id: OAuth client ID this state was generated for
        redirect_uri: OAuth redirect URI this state was generated for
        created_at: Unix timestamp when state was created
        expires_at: Unix timestamp when state expires
    """

    value: str
    client_id: str
    redirect_uri: str
    created_at: float
    expires_at: float


class CSRFProtection:
    """CSRF protection using state parameter validation for OAuth flows.

    This class implements CSRF protection for OAuth authorization flows by:
    1. Generating cryptographically secure state parameters
    2. Storing state metadata with expiration times
    3. Validating state parameters match expected client/redirect URI
    4. Ensuring one-time use of state parameters
    5. Automatic cleanup of expired states

    Example:
        csrf = CSRFProtection(expiration_seconds=600)

        # Generate state for OAuth request
        state = csrf.generate_state("client_123", "http://localhost:3001/callback")

        # Later, validate state from callback
        is_valid = csrf.validate_state(state, "client_123", "http://localhost:3001/callback")
    """

    def __init__(self, expiration_seconds: int = 600) -> None:
        """Initialize CSRF protection with configurable expiration.

        Args:
            expiration_seconds: How long state parameters remain valid in seconds.
                               Default is 600 seconds (10 minutes).
        """
        self.expiration_seconds = expiration_seconds
        self._states: dict[str, CSRFState] = {}
        logger.info(
            f"Initialized CSRF protection with {expiration_seconds}s expiration"
        )

    def generate_state(self, client_id: str, redirect_uri: str) -> str:
        """Generate a cryptographically secure CSRF state parameter.

        Creates a new state parameter bound to the specific client ID and redirect URI.
        The state is stored internally for later validation and automatically expires
        after the configured time period.

        Args:
            client_id: OAuth client ID this state will be used with
            redirect_uri: OAuth redirect URI this state will be used with

        Returns:
            Generated state parameter (URL-safe base64 string)

        Raises:
            ValueError: If client_id or redirect_uri are empty
        """
        if not client_id:
            raise ValueError("client_id cannot be empty")
        if not redirect_uri:
            raise ValueError("redirect_uri cannot be empty")

        # Generate cryptographically secure random state
        state_value = secrets.token_urlsafe(32)
        now = time.time()

        # Create and store state metadata
        csrf_state = CSRFState(
            value=state_value,
            client_id=client_id,
            redirect_uri=redirect_uri,
            created_at=now,
            expires_at=now + self.expiration_seconds,
        )

        self._states[state_value] = csrf_state

        logger.debug(
            f"Generated CSRF state {state_value[:8]}... for client {client_id}"
        )
        return state_value

    def validate_state(
        self, state: str | None, client_id: str, redirect_uri: str
    ) -> bool:
        """Validate a CSRF state parameter for OAuth callback.

        Validates that:
        1. State parameter exists and is not empty
        2. State was previously generated by this instance
        3. State has not expired
        4. State was generated for the same client_id and redirect_uri

        The state parameter is consumed (deleted) after successful validation
        to prevent replay attacks.

        Args:
            state: State parameter to validate (may be None or empty)
            client_id: Expected OAuth client ID
            redirect_uri: Expected OAuth redirect URI

        Returns:
            True if state is valid and matches parameters, False otherwise
        """
        # Check for empty or None state
        if not state:
            logger.warning(f"Missing state parameter for client {client_id}")
            return False

        # Check if state exists in our store
        if state not in self._states:
            logger.warning(
                f"Unknown state parameter {state[:8]}... for client {client_id}"
            )
            return False

        csrf_state = self._states[state]

        # Check expiration
        current_time = time.time()
        if current_time > csrf_state.expires_at:
            logger.warning(
                f"Expired state parameter {state[:8]}... for client {client_id} "
                f"(expired {current_time - csrf_state.expires_at:.1f}s ago)"
            )
            del self._states[state]
            return False

        # Check client ID matches
        if csrf_state.client_id != client_id:
            logger.warning(
                f"State parameter {state[:8]}... client ID mismatch: "
                f"expected {client_id}, got {csrf_state.client_id}"
            )
            return False

        # Check redirect URI matches
        if csrf_state.redirect_uri != redirect_uri:
            logger.warning(
                f"State parameter {state[:8]}... redirect URI mismatch: "
                f"expected {redirect_uri}, got {csrf_state.redirect_uri}"
            )
            return False

        # Valid state - consume it to prevent replay attacks
        del self._states[state]

        logger.debug(
            f"Successfully validated and consumed CSRF state {state[:8]}... "
            f"for client {client_id}"
        )
        return True

    def cleanup_expired(self) -> None:
        """Remove expired state parameters from storage.

        This method should be called periodically to prevent memory leaks
        from accumulated expired states. In production, consider calling
        this from a background task or scheduled job.
        """
        current_time = time.time()

        expired_states = [
            state_value
            for state_value, csrf_state in self._states.items()
            if current_time > csrf_state.expires_at
        ]

        for state_value in expired_states:
            del self._states[state_value]

        if expired_states:
            logger.info(f"Cleaned up {len(expired_states)} expired CSRF states")
